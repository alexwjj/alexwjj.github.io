---
title: 【每日学习打卡】4.22  React主题月
sidebar: "auto"
date: 2021-04-22
tags:
  - 学习打卡
categories:
  - 学习打卡
---

> 新的一个月，新的开始，🆙  月底再总结一波

<!-- more -->

## flag

- 晚上不吃饭减肥搞起来，这个搞起来了
- 周3周5 6点下班，跑步回家。刚入职有点懵逼，就先放放
- 每天晚上回家刷一道算法题，一周两道就不错了，害
- 番茄工作法！！！🍅🍅🍅
- 两周冲刺！！！！
- 需要给自己定一个目标，每个月的学习主题是什么，类似于早早聊
- 三个月打卡，得到了什么
## 4.22
### web api 通信相关
团队技术分享，开头举了个面试题：浏览器多个tab打开网易云音乐，一个tab下播放，另外一个tab要暂停，怎么做？

开始我想的是用下面这两种，但是这样只能离开页面就关闭，没法和另外一个页面共享状态
```js
window.onbeforeunload=function(e){     
　　var e = window.event||e;  
　　e.returnValue=("确定离开当前页面吗？");
}
// 页面的 visibilityState属性可能返回三种状态 prerender，visible 和 hidden 
// 监听 visibility change 事件 
document.addEventListener('visibilitychange', function() {
  // 页面变为不可见时触发 
  if (document.visibilityState == 'hidden') {
    document.title = '离开';
  } 
  // 页面变为可见时触发 
  if (document.visibilityState == 'visible') { 
    document.title = '回来';
  } 
});
```

还举例了另外一个场景，当前页面有个富文本，正在编辑。另外一个tab打开相同的页面，也要编辑，然后引出锁的问题。
言外之意就是模拟协同办公那种情况，后续深入了解一下
#### 1、storage
```js
window.onstorage = (e) => {console.log(e)}
// 或者这样
window.addEventListener('storage', (e) => console.log(e))
```
- 前提：两个页面必须同源
- 针对非当前页面Storages，使用local和session都可以触发，当前页面修改Storage不会触发监听函数，修改的值不变，也不会触发

#### 2、webscoket
全双工通信

#### 3、webworker
- webworker作为浏览器的一个新特性，可以提供一个额外的线程来执行一些js代码，并且不会影响到浏览器用户界面。

#### 4、SharedWorker
- SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)

#### 5、BroadcastChannel
每个页面通过创建一个具有相同频道名称的 BroadcastChannel 对象来加入特定频道。 然后实现 onmessage 接口来监听消息事件。通过调用 BroadcastChannel 对象上的 postMessage() 方法可以在频道中广播一条消息给所有订阅者。

移动端safri不支持BroadcastChannel
### webpack 热更新
团队技术分享主题，没有PPT，讲的比较快，不太理解，自己再研究下
- webpack-dev-server 建立本地和浏览器的websocket链接
- 本地代码更新，触发compiler.watch(监听本地文件的变化主要是通过文件的生成时间是否有变化)，compiler完成会触发tapable的钩子, 在钩子里通过websocket通知浏览器触发更新，会发两个请求`xxx/hash.hot-update.json` 和 `xxx/hash.hot-update.js` js通过JSONP插入到页面中
- 通过hotApply热更新模块替换
[webpack 热更新流程图](https://user-gold-cdn.xitu.io/2019/12/1/16ec13499800dfce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
### padStart()、padEnd()
 A.padStart(length, string) 用string 从左开始填充A，直到达到最大length，padEnd从右开始
 ```js
 let a = '333';
 let b = a.padStart(5, '0')
 b //"00333"
 ```

### 大数相加
- 先处理两个数，让位数相同，后续进位
- 根据进位情况，%取余，Math.floor取整数
### 一些误解

受控组件泛指，input，checkbox，textarea等等，只是react修改数据需要用setState，vue内部帮忙做掉了。

数据流，vue和react都是单向数据流，都不允许直接修改props

v-model语法糖，之前一直以为都是监听的onChange，vue官网也写了会根据组件类型进行处理，input和change事件，见下解释
### vue v-model 受控组件
v-model 指令在表单 <input>、<textarea> 及 <select> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。

v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：

- text 和 textarea 元素使用 value property 和 `input 事件`；
- checkbox 和 radio 使用 checked property 和 `change 事件`；
- select 字段将 value 作为 prop 并将 `change 作为事件`。
### 技术文章的意义
昨天发了个文章，写了一些自己的理解，网友指出了一些错误，这就是意义

有些自以为对的东西，只是自己觉得。别人不说，你就不知道，加入面试暴露了，就有
直接挂掉的可能

所以，多写写，不要抄，就把自己的理解写出来。
## 4.21
### 查询npm包最新版本
yarn info react

### 升级固定版本，不带 ^
yarn add react@17.0.2

## 4.20
### React + TypeScript 实践
字节文章 [React + TypeScript 实践](https://mp.weixin.qq.com/s/mUblBpj6pmdxz9mLKEDJTw)
### 使用 Type 还是 Interface？
- 在定义公共 API 时(比如编辑一个库）使用 interface，这样可以方便使用者继承接口
- 在定义组件属性（Props）和状态（State）时，建议使用 type，因为 type的约束性更强

type 和 interface 最大的区别是：type 不支持声明合并，而 interface 可以随时扩展
### useRef<T>
```js
// 第一种方式的 ref1.current 是只读的（read-only），并且可以传递给内置的 ref 属性，绑定 DOM 元素 ；
const ref1 = React.useRef<HTMLInputElement>(null)
// 第二种方式的 ref2.current 是可变的（类似于声明类的成员变量）
const ref2 = React.useRef<HTMLInputElement | null>(null)
```
### useState<T>
```js
// `val`会推导为boolean类型， toggle接收boolean类型参数
const [val, toggle] = React.useState(false)

type User = {
  name: string
  age: number
}
// 一些状态初始值为空时（null），需要显示地声明类型：
const [user, setUser] = React.useState<User | null>(null)
```
### 函数组件写法
#### 1、React.FC写法
```js
type AppProps = {
  message: string
}

const App: React.FC<AppProps> = ({ message, children }) => (
  <div>
    {message}
    {children}
  </div>
)
```
#### 2、React.PropsWithChildren
```js
type AppProps = React.PropsWithChildren<{ message: string }>
const App = ({ message, children }: AppProps) => (
  <div>
    {message}
    {children}
  </div>
)
```
#### 3.直接声明
```js
type AppProps = {
  message: string
  children?: React.ReactNode
}

const App = ({ message, children }: AppProps) => (
  <div>
    {message}
    {children}
  </div>
)
```
## 4.19

### yarn-lock
升级包版本的时候不要去package.json直接改版本号，用命令的形式，yarn add xxx@1.1.1，yarn-lock会只更新当前安装包的版本
### Object.seal()
Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。

对象原有属性可以修改
```js
const people = {
    age: 18
}
Object.seal(people)
delete people.age
people.name = 'JJ'
people.age = 29
console.log(people)// { age: 29 }
```
### 装饰器模式

```js
function thinFace() {
  console.log('开启瘦脸')
}
function IncreasingEyes() {
  console.log('增大眼睛')
}

@thinFace
@IncreasingEyes
class Girl {
}
// '增大眼睛'
// '开启瘦脸'
```
编译成 js 代码，在运行时，会直接调用 thinFace 函数。这个装饰器作用在类上，称之为类装饰器

多个装饰器组合在一起，在运行时，要注意，调用顺序是 从下至上 依次调用，正好和书写的顺序相反。

装饰器这块有点学问，得多研究下
## 4.18
### 新的生活区
换工作以后搬家，随之而来的就是新的生活区，丰潭路这边算是西湖比较老的地方，老小区，老马路，and老人，
可能是对新生活的期望太大，心理预期差太多，导致有些失落。

不过这些都是适应问题，一段时间内总有自己留念的事物，也应该好好珍惜现在的一些，过眼云烟，都是尘埃往事。

### 思考🤔
和个人性格有关吧，只要有个问题卡在心上，自己就会一直不停的去想，去幻想各种最坏的结果。

然后给自己带来的就是无尽的焦虑。也好也坏，经常白天想的一个bug，梦里遇到了，然后梦里解决了，醒了有思路了，问题就解决了，这种情况在我这好几次了。。。

### 关于node
node和java的区别？node作为bff到底好在哪？node是一门后端语言吗？等等问题，网上找也都说的天花乱坠的，读完也没有get到点。需要多写写，写多了就知道了，相信一点，勤能补拙！
## 4.17

### 上午，改bug
周六上午又来了俩线上bug，在家慢慢查。u1s1，小程序这东西真的。。。

### react 
实战项目视频学习

### 小程序生命周期
1.`onLoad`:和`beforeMounted`相似

2.`onShow`:onLoad执行的时候onShow也会执行。同样，onLoad会先于`onShow`执行

3.`onReady`:和mounted相似，三者执行顺序：`onLoad onShow onReady`

4.`onHide`:隐藏，例如使用 `wx.navigateTo`  只是打开新页面  并不关闭原页面

5.`onUnload`:卸载，例如使用 `wx.redirectTo,wx.navigateBack`  重定向一个页面 原页面已经关闭

小程序tab切换，只执行一次`onLoad`，然后页面被缓存，再次进来执行`onShow`，监听tab切换可以用`onTabItemTap`生命周期
## 4.16
### 取消merge
执行git merge之后，vscode放弃了本地的一些修改，这个时候pull代码就会报错`您尚未结束您的合并（存在 MERGE_HEAD）`

执行下即可 `git merge --abort`
### reactis
一款基于模型的测试、仿真和验证工具

### 买房攻略
准备搞起来，七月份社保满两年，开始看房
## 4.15 
### StrictMode
StrictMode目前有助于：

- ①识别不安全的生命周期。
- ②关于使用过时字符串 ref API 的警告
- ③关于使用废弃的 findDOMNode 方法的警告
- ④检测意外的副作用
- ⑤检测过时的 context API

对于不安全的生命周期，指的是UNSAFE_componentWillMount，UNSAFE_componentWillReceiveProps , UNSAFE_componentWillUpdate,使用这些就会报错
### Profiler
Profiler这个api一般用于开发阶段，性能检测，检测一次react组件渲染用时，性能开销。

Profiler 需要两个参数：

- 第一个参数：是 id，用于表识唯一性的Profiler。

- 第二个参数：onRender回调函数，用于渲染完成，接受渲染参数
### Suspense
Suspense 让组件“等待”某个异步操作，直到该异步操作结束即可渲染。
```js
<Suspense fallback={<Spinner />}>
  <ProfilePage />
</Suspense>
```
### forwardRef 
父组件想获取孙组件，某一个dom元素。这种隔代ref获取引用，就需要forwardRef来助力 
### 监控平台
之前就接触过sentry，用的也很少，刚来就接触了俩监控平台，对于这块知识比较欠缺

只了解一些全局监听错误的方式，vue handlerError，window.onError,promise unxx好长一串

有个大哥准备搞个开源的监控平台，和他好好学习学习
## 4.14
### 技术新人培训
一天脱产培训，感觉有赞这边还是挺重视技术的
### react复习
培训讲中间件的时候听不懂，也没电脑手机，就在小本本上写写画画

巩固一下大脑里面的react生命周期图，写了两遍还是有一些收货的。就比如forceUpdate
不会经过shouldComponentUpdate

### React.memo和pureComponent区别
React.memo 监听的props变化

pureComponent 是监听props和state的变化，会进行浅比较，来判断要不要更新组件

### useEffect 第二个参数
```js
useEffect(() => {
    console.log('effect');
    return () => {
      console.log('returnFunction');
    };
  },[]);
```
- 空，则每次 componentDidUpdate 时都会  先触发 returnFunction（如果存在），再触发 effect
- [] 模拟 componentDidMount, returnFunction（如果存在） 不会执行
- [id] 仅在 id 的值发生变化以后触发, 先触发 returnFunction（如果存在），再触发 effect 

所以尽量不要写空的, 注意是先触发 returnFunction 再 effect

## 4.13

### a 标签
anchor a标签就是这个单词的缩写，对应HTMLAnchorElement类型
### postman 拦截浏览器请求
使用插件：Postman Interceptor

[postman interceptor使用介绍](https://blog.csdn.net/anywayiknow/article/details/79195279)
### 焦虑感
随想
### vue & react对比

## 4.12 

### createRef
- React.createRef主要用在class组件中，用于创建refs
- createRef和useRef可以用来保存任何值
- ref中值的改变不会触发组件更新

createRef 和 useRef， 在初始化阶段两个是没区别的，但是在更新阶段两者是有区别的。
### useRef
useRef 创建的 ref 仿佛就像在函数外部定义的一个`全局变量`，不会随着组件的更新而重新创建。但组件销毁，它也会消失，不用手动进行销毁

- useRef，主要用在函数组件中
- 注意：因为函数组件没有实例，如果想用ref获取子组件的实例，子组件组要写成类组件
- 高阶组件上使用refs转发，refs 将不会透传下去。这是因为 ref 不是 prop 属性。就像 key 一样
- 可以理解为和vue ref作用相同，都是为了获取指定dom

```js
import React, { Component, useEffect, useRef } from 'react';
function App() {
  const childRef = useRef();
  useEffect(() => {
    console.log('useRef')
    console.log(childRef.current)
    childRef.current.handleLog();
  }, [])
  return (
    <div>
      <h1>Hello World!</h1>
      <Child ref={childRef} count="1"/>
    </div>
  )
}
// 因为函数组件没有实例，如果想用ref获取子组件的实例，子组件组要写成类组件
class Child extends Component {
  handleLog = () => {
    console.log('Child Component');
  }
  render() {
    const { count } = this.props;
    return <h2>count: { count }</h2>
  }
}
export default App;

```

### input 受控组件
给input这种组件默认值，是会直接报错`value` prop to a form field without an `onChange` handler,

这和react有关，react中修改值是通过setState的，可以用onChange来修改，或者直接添加readOnly属性

### css module
- 建立 study.module.css
- import style from './study.module.css'
- <div className={style.jj}></div>
- 浏览器显示 <div class="style_cssmodule__1qEwN">css-module-study练习</div>
### react组件样式覆盖
给父容器一个className，直接修改就行

如需要声明全局的：
```js
:global(.zent-block-header) {
  margin-bottom: 15px;
}
```
## 4.11

### react markdown
### zent组件

基本都写了一遍，熟悉的七七八八了，接下来开始业务组件库的操作了，顺便练习练习react和ts，冲冲冲
## 4.10

### 吵架
累了累了，动不动就吵架。这次的原因：马上我要过生日了，非要让我自己选好生日礼物，然后她给我买。我不选，我觉得这样很没意思，所以开始折磨我，啥也不让我干，就这么不讲理。昨天的周年纪恋日真是浪费，亏我想了那么久。

### ts Utility Type
写了一篇笔记，写了写demo

相当于是ts的一些封装，type用的很多，得多用用type.

### 前同事聚会

之前在微医的组长这周五也离职了，去了总结，薪资无敌，原地起飞。

四百一个人的海鲜自助，五个男人，战斗力都不行，亏得很，根本吃不回来。

晚上十二点多到家，又开始了忧虑，我什么时候能和这些大佬一样？
## 4.9 

### 新人培训第3天
完结、散花
### TypeScript中的any和unknown的区别
简单说下，any可是是任何类型的父类或者是子类，是类型不安全的，什么是类型不安全？很好理解，就是平常我们懒得写定义，直接any，让编译器忽略检查any类型的值，这么做就会产生一些意想不到的情况，导致代码出错，而且很难去排查。而unknown则是类型安全的，unknown也是可以赋值任何值，但是当我们进行使用它进行一些操作的时候，比如把unknown类型的值作为一种方法来调用，编译器就会报错，因为你不确定这个变量是不是个方法，因此是不能调用的，需要在调用前确保它可以被调用。

```js
let fn:unknown = () => {};
if(typeof fn === 'function') {
    fn();
}
```
## 4.8 

### 新人培训第2天

## 4.7 
### 新人培训第1天
时间安排的比较紧凑，三个班级，近一百人，来着全国各个地方。优秀的人很多，能说会道的人很多，沉默的一看就是干技术的~~~
### 6号晚
7-9点已经搞过一波了，感觉有点累，心里带着学习的负担，一点话都不想说。。。。
### 三天
三天的培训，个人的心态得调整下，Just Do It！！！
## 4.6 
### react hooks demo
写了几个，useCallback,useMemo,useEffect,useContext,useReducer，写自定义hooks报了错，莫名其妙，暂时还没解决
### 完成todo list
后面再学学新的东西，可以优化一波，加一些新功能
### mac git安装 
系统更新了一波，结果Git环境没了，奇奇怪怪

- [MAC上Git安装与GitHub基本使用](https://www.jianshu.com/p/7edb6b838a2e)
- 先安装brew,安装比较慢，执行`/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"`
- 安装完成会有个提醒：`Add Homebrew to your PATH in /Users/wujunjie/.zprofile:`
- 修改_base_profile,找不到文件的，cmd+shift+g 输入 / 
- 或者直接命令行`vi .bash_profile` 添加提示内容
- source .bash_profile 生效
```js
echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> /Users/wujunjie/.zprofile
eval "$(/opt/homebrew/bin/brew shellenv)"
```
## 4.5

### todo list
react写个todolist，仿造公司的需求管理平台，完成50%

看和写差不多还是很多的，遇到些问题，明天请教下大哥们

### zent form
写了写，zent 的form表单，比较在pc端，这是最重要的。

和vue的开发模式差别挺大，目前还不熟练，多在自己的学习项目多写写，同时练习ts

### useCallback，useMemo
写了几个demo，基本会用了


## 4.4

### react 实站学习
### RFC
Request For Comments
### vue3 放弃IE11

之前面涂鸦有被问到，vue3如何兼容IE11，我说降级处理，使用defineProperty。面试官说那不就回到了vue2了，我无言以对。实际上他说他想了解的是看我会不会往polyfill方面想。实际上，vue3用的proxy是浏览器级别的东西，没法用polyfill支持。

最近尤大提了RFC，在vue3中会放弃IE11，并且将精力投入在vue2.7版本，加入一些优化，支持composition-api，加入vite等等。

萌新表示大力支持！！！

### Object.create(proto, [propertiesObject])

`let a = Object.create(null)` 这样创建的a 无任何属性，原型也没有

如下创建，可以指定创建对象的原型指向

```js
var person = {
    address: "world"
}

var son = Object.create(person, {
    age: {
        value: 23
    }
});
console.log(son.address);    // world
```

## 4.3

### zent熟悉

公司的开源的组件库，之前一直有计划来写一遍，一直都在脱，现在有了目标，就有动力了。

今天写了三大类，基础组件类，导航类，数据类。剩下两类明天写完！！！

### react学习文档

对比vue学，先记录着，后面学完了整理一下，对外输出一波
## 4.2

### promise.any()

该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。

和race很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。

### 关于最近
来公司一个月了，但是熟悉项目比较慢，大部分时间都用在了聊天。掘金发了两篇文章，大量的人加我咨询一些学习方法，或者是内推，有点忘记了自己的事情。领导给了指标，对我的一些期望，希望自己能达到要求。这段时间就好好学习了，冲冲冲！！！！

## 4.1

### snowpack
- 目前bundleless的开发工具主要有两个: vite 和 snowpack,两者内部都用到了rollUp,都是基于浏览器的ESM来设计的
- snowpack可以通过plugin的方式接入webpack并用于生产，如 @snowpack/plugin-webpack
- vite则使用rollup这一bundle工具作为内置的生产打包工具



