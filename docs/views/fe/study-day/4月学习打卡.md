---
title: 【每日学习打卡】4.19
sidebar: "auto"
date: 2021-04-19
tags:
  - 学习打卡
categories:
  - 学习打卡
---

> 新的一个月，新的开始，🆙  月底再总结一波

<!-- more -->

## flag

- 晚上不吃饭减肥搞起来，这个搞起来了
- 周3周5 6点下班，跑步回家。刚入职有点懵逼，就先放放
- 每天晚上回家刷一道算法题，一周两道就不错了，害
- 番茄工作法！！！🍅🍅🍅
- 两周冲刺！！！！
- 需要给自己定一个目标，每个月的学习主题是什么，类似于早早聊
- 三个月打卡，得到了什么

## 4.19

### yarn-lock
升级包版本的时候不要去package.json直接改版本号，用命令的形式，yarn add xxx@1.1.1，yarn-lock会只更新当前安装包的版本
### Object.seal()
Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。

对象原有熟悉可以修改
```js
const people = {
    age: 18
}
Object.seal(people)
delete people.age
people.name = 'JJ'
people.age = 29
console.log(people)// { age: 29 }
```
### 装饰器模式

```js
function thinFace() {
  console.log('开启瘦脸')
}
function IncreasingEyes() {
  console.log('增大眼睛')
}

@thinFace
@IncreasingEyes
class Girl {
}
// '增大眼睛'
// '开启瘦脸'
```
编译成 js 代码，在运行时，会直接调用 thinFace 函数。这个装饰器作用在类上，称之为类装饰器

多个装饰器组合在一起，在运行时，要注意，调用顺序是 从下至上 依次调用，正好和书写的顺序相反。

装饰器这块有点学问，得多研究下
## 4.18
### 新的生活区
换工作以后搬家，随之而来的就是新的生活区，丰潭路这边算是西湖比较老的地方，老小区，老马路，and老人，
可能是对新生活的期望太大，心理预期差太多，导致有些失落。

不过这些都是适应问题，一段时间内总有自己留念的事物，也应该好好珍惜现在的一些，过眼云烟，都是尘埃往事。

### 思考🤔
和个人性格有关吧，只要有个问题卡在心上，自己就会一直不停的去想，去幻想各种最坏的结果。

然后给自己带来的就是无尽的焦虑。也好也坏，经常白天想的一个bug，梦里遇到了，然后梦里解决了，醒了有思路了，问题就解决了，这种情况在我这好几次了。。。

### 关于node
node和java的区别？node作为bff到底好在哪？node是一门后端语言吗？等等问题，网上找也都说的天花乱坠的，读完也没有get到点。需要多写写，写多了就知道了，相信一点，勤能补拙！
## 4.17

### 上午，改bug
周六上午又来了俩线上bug，在家慢慢查。u1s1，小程序这东西真的。。。

### react 
实战项目视频学习

### 小程序生命周期
1.`onLoad`:和`beforeMounted`相似

2.`onShow`:onLoad执行的时候onShow也会执行。同样，onLoad会先于`onShow`执行

3.`onReady`:和mounted相似，三者执行顺序：`onLoad onShow onReady`

4.`onHide`:隐藏，例如使用 `wx.navigateTo`  只是打开新页面  并不关闭原页面

5.`onUnload`:卸载，例如使用 `wx.redirectTo,wx.navigateBack`  重定向一个页面 原页面已经关闭

小程序tab切换，只执行一次`onLoad`，然后页面被缓存，再次进来执行`onShow`，监听tab切换可以用`onTabItemTap`生命周期
## 4.16
### 取消merge
执行git merge之后，vscode放弃了本地的一些修改，这个时候pull代码就会报错`您尚未结束您的合并（存在 MERGE_HEAD）`

执行下即可 `git merge --abort`
### reactis
一款基于模型的测试、仿真和验证工具

### 买房攻略
准备搞起来，七月份社保满两年，开始看房
## 4.15 
### StrictMode
StrictMode目前有助于：

- ①识别不安全的生命周期。
- ②关于使用过时字符串 ref API 的警告
- ③关于使用废弃的 findDOMNode 方法的警告
- ④检测意外的副作用
- ⑤检测过时的 context API

对于不安全的生命周期，指的是UNSAFE_componentWillMount，UNSAFE_componentWillReceiveProps , UNSAFE_componentWillUpdate,使用这些就会报错
### Profiler
Profiler这个api一般用于开发阶段，性能检测，检测一次react组件渲染用时，性能开销。

Profiler 需要两个参数：

- 第一个参数：是 id，用于表识唯一性的Profiler。

- 第二个参数：onRender回调函数，用于渲染完成，接受渲染参数
### Suspense
Suspense 让组件“等待”某个异步操作，直到该异步操作结束即可渲染。
```js
<Suspense fallback={<Spinner />}>
  <ProfilePage />
</Suspense>
```
### forwardRef 
父组件想获取孙组件，某一个dom元素。这种隔代ref获取引用，就需要forwardRef来助力 
### 监控平台
之前就接触过sentry，用的也很少，刚来就接触了俩监控平台，对于这块知识比较欠缺

只了解一些全局监听错误的方式，vue handlerError，window.onError,promise unxx好长一串

有个大哥准备搞个开源的监控平台，和他好好学习学习
## 4.14
### 技术新人培训
一天脱产培训，感觉有赞这边还是挺重视技术的
### react复习
培训讲中间件的时候听不懂，也没电脑手机，就在小本本上写写画画

巩固一下大脑里面的react生命周期图，写了两遍还是有一些收货的。就比如forceUpdate
不会经过shouldComponentUpdate

### React.memo和pureComponent区别
React.memo 监听的props变化

pureComponent 是监听props和state的变化，会进行浅比较，来判断要不要更新组件

### useEffect 第二个参数
```js
useEffect(() => {
    console.log('effect');
    return () => {
      console.log('returnFunction');
    };
  },[]);
```
- 空，则每次 componentDidUpdate 时都会  先触发 returnFunction（如果存在），再触发 effect
- [] 模拟 componentDidMount, returnFunction（如果存在） 不会执行
- [id] 仅在 id 的值发生变化以后触发, 先触发 returnFunction（如果存在），再触发 effect 

所以尽量不要写空的, 注意是先触发 returnFunction 再 effect

## 4.13

### a 标签
anchor a标签就是这个单词的缩写，对应HTMLAnchorElement类型
### postman 拦截浏览器请求
使用插件：Postman Interceptor

[postman interceptor使用介绍](https://blog.csdn.net/anywayiknow/article/details/79195279)
### 焦虑感
随想
### vue & react对比

## 4.12 

### createRef
- React.createRef主要用在class组件中，用于创建refs
- createRef和useRef可以用来保存任何值
- ref中值的改变不会触发组件更新

createRef 和 useRef， 在初始化阶段两个是没区别的，但是在更新阶段两者是有区别的。
### useRef
useRef 创建的 ref 仿佛就像在函数外部定义的一个`全局变量`，不会随着组件的更新而重新创建。但组件销毁，它也会消失，不用手动进行销毁

- useRef，主要用在函数组件中
- 注意：因为函数组件没有实例，如果想用ref获取子组件的实例，子组件组要写成类组件
- 高阶组件上使用refs转发，refs 将不会透传下去。这是因为 ref 不是 prop 属性。就像 key 一样
- 可以理解为和vue ref作用相同，都是为了获取指定dom

```js
import React, { Component, useEffect, useRef } from 'react';
function App() {
  const childRef = useRef();
  useEffect(() => {
    console.log('useRef')
    console.log(childRef.current)
    childRef.current.handleLog();
  }, [])
  return (
    <div>
      <h1>Hello World!</h1>
      <Child ref={childRef} count="1"/>
    </div>
  )
}
// 因为函数组件没有实例，如果想用ref获取子组件的实例，子组件组要写成类组件
class Child extends Component {
  handleLog = () => {
    console.log('Child Component');
  }
  render() {
    const { count } = this.props;
    return <h2>count: { count }</h2>
  }
}
export default App;

```

### input 受控组件
给input这种组件默认值，是会直接报错`value` prop to a form field without an `onChange` handler,

这和react有关，react中修改值是通过setState的，可以用onChange来修改，或者直接添加readOnly属性

### css module
- 建立 study.module.css
- import style from './study.module.css'
- <div className={style.jj}></div>
- 浏览器显示 <div class="style_cssmodule__1qEwN">css-module-study练习</div>
### react组件样式覆盖
给父容器一个className，直接修改就行

如需要声明全局的：
```js
:global(.zent-block-header) {
  margin-bottom: 15px;
}
```
## 4.11

### react markdown
### zent组件

基本都写了一遍，熟悉的七七八八了，接下来开始业务组件库的操作了，顺便练习练习react和ts，冲冲冲
## 4.10

### 吵架
累了累了，动不动就吵架。这次的原因：马上我要过生日了，非要让我自己选好生日礼物，然后她给我买。我不选，我觉得这样很没意思，所以开始折磨我，啥也不让我干，就这么不讲理。昨天的周年纪恋日真是浪费，亏我想了那么久。

### ts Utility Type
写了一篇笔记，写了写demo

相当于是ts的一些封装，type用的很多，得多用用type.

### 前同事聚会

之前在微医的组长这周五也离职了，去了总结，薪资无敌，原地起飞。

四百一个人的海鲜自助，五个男人，战斗力都不行，亏得很，根本吃不回来。

晚上十二点多到家，又开始了忧虑，我什么时候能和这些大佬一样？
## 4.9 

### 新人培训第3天
完结、散花
### TypeScript中的any和unknown的区别
简单说下，any可是是任何类型的父类或者是子类，是类型不安全的，什么是类型不安全？很好理解，就是平常我们懒得写定义，直接any，让编译器忽略检查any类型的值，这么做就会产生一些意想不到的情况，导致代码出错，而且很难去排查。而unknown则是类型安全的，unknown也是可以赋值任何值，但是当我们进行使用它进行一些操作的时候，比如把unknown类型的值作为一种方法来调用，编译器就会报错，因为你不确定这个变量是不是个方法，因此是不能调用的，需要在调用前确保它可以被调用。

```js
let fn:unknown = () => {};
if(typeof fn === 'function') {
    fn();
}
```
## 4.8 

### 新人培训第2天

## 4.7 
### 新人培训第1天
时间安排的比较紧凑，三个班级，近一百人，来着全国各个地方。优秀的人很多，能说会道的人很多，沉默的一看就是干技术的~~~
### 6号晚
7-9点已经搞过一波了，感觉有点累，心里带着学习的负担，一点话都不想说。。。。
### 三天
三天的培训，个人的心态得调整下，Just Do It！！！
## 4.6 
### react hooks demo
写了几个，useCallback,useMemo,useEffect,useContext,useReducer，写自定义hooks报了错，莫名其妙，暂时还没解决
### 完成todo list
后面再学学新的东西，可以优化一波，加一些新功能
### mac git安装 
系统更新了一波，结果Git环境没了，奇奇怪怪

- [MAC上Git安装与GitHub基本使用](https://www.jianshu.com/p/7edb6b838a2e)
- 先安装brew,安装比较慢，执行`/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"`
- 安装完成会有个提醒：`Add Homebrew to your PATH in /Users/wujunjie/.zprofile:`
- 修改_base_profile,找不到文件的，cmd+shift+g 输入 / 
- 或者直接命令行`vi .bash_profile` 添加提示内容
- source .bash_profile 生效
```js
echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> /Users/wujunjie/.zprofile
eval "$(/opt/homebrew/bin/brew shellenv)"
```
## 4.5

### todo list
react写个todolist，仿造公司的需求管理平台，完成50%

看和写差不多还是很多的，遇到些问题，明天请教下大哥们

### zent form
写了写，zent 的form表单，比较在pc端，这是最重要的。

和vue的开发模式差别挺大，目前还不熟练，多在自己的学习项目多写写，同时练习ts

### useCallback，useMemo
写了几个demo，基本会用了


## 4.4

### react 实站学习
### RFC
Request For Comments
### vue3 放弃IE11

之前面涂鸦有被问到，vue3如何兼容IE11，我说降级处理，使用defineProperty。面试官说那不就回到了vue2了，我无言以对。实际上他说他想了解的是看我会不会往polyfill方面想。实际上，vue3用的proxy是浏览器级别的东西，没法用polyfill支持。

最近尤大提了RFC，在vue3中会放弃IE11，并且将精力投入在vue2.7版本，加入一些优化，支持composition-api，加入vite等等。

萌新表示大力支持！！！

### Object.create(proto, [propertiesObject])

`let a = Object.create(null)` 这样创建的a 无任何属性，原型也没有

如下创建，可以指定创建对象的原型指向

```js
var person = {
    address: "world"
}

var son = Object.create(person, {
    age: {
        value: 23
    }
});
console.log(son.address);    // world
```

## 4.3

### zent熟悉

公司的开源的组件库，之前一直有计划来写一遍，一直都在脱，现在有了目标，就有动力了。

今天写了三大类，基础组件类，导航类，数据类。剩下两类明天写完！！！

### react学习文档

对比vue学，先记录着，后面学完了整理一下，对外输出一波
## 4.2

### promise.any()

该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。

和race很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。

### 关于最近
来公司一个月了，但是熟悉项目比较慢，大部分时间都用在了聊天。掘金发了两篇文章，大量的人加我咨询一些学习方法，或者是内推，有点忘记了自己的事情。领导给了指标，对我的一些期望，希望自己能达到要求。这段时间就好好学习了，冲冲冲！！！！

## 4.1

### snowpack
- 目前bundleless的开发工具主要有两个: vite 和 snowpack,两者内部都用到了rollUp,都是基于浏览器的ESM来设计的
- snowpack可以通过plugin的方式接入webpack并用于生产，如 @snowpack/plugin-webpack
- vite则使用rollup这一bundle工具作为内置的生产打包工具



