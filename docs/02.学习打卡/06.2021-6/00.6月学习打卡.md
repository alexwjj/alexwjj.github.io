---
title: 【学习打卡】6-8
sidebar: auto
date: 2021-06-08 00:00:00
sticky: true
tags:
  - 学习打卡
categories:
  - 学习打卡
permalink: /pages/a606010c57cc5/
---

> 真就减不下去？废物？

<!-- more -->

## 体重记录

- 5 月 减肥 3.4 斤，太惨了
- 6.1: 146.6
- 6.2: 146.0
- 6.3: 146.0
- 6.4: 145.3
- 6.5: 
- 6.6:
- 6.7: 146.5
- 6.8: 146.1
## 6.8
### Emoji小网站
[Emoji小网站 很好玩](https://emojixd.com/)
### html显示LaTeX数学公式
[MathJax](https://www.mathjax.org/) 

[KaTeX](https://katex.org/) 貌似更强，速度更块
## 6.7
### BFF 实践PDF
[蚂蚁财富的 BFF 实践 - 汤尧（新） 在线PDF](https://os.alipayobjects.com/rmsportal/WtUmBLJSmqtDHkvJzuzM.pdf)

### git learn

[https://learngitbranching.js.org/](https://learngitbranching.js.org/)

可视化 git 操作，玩的不太会。。。挺有意思

### Nunjucks

模板引擎 [中文文档]https://nunjucks.bootcss.com/getting-started.html()
## 6.6
### 敲敲vue
这才三个月，有些东西写着写着就忘记了写法，hhh

### npm version  <update_type>
update_type为patch, minor, major其中之一，分别表示补丁，小改，大改
```js
npm version patch

npm version minor

npm version major

```

## 6.5

### 汽修培训
前同事和前TL都在，吹吹nb，一天就过去了。后悔报这个班了，没啥用，还暂用时间。
## 6.4

### peerDependencies
目的是提示宿主环境去安装满足插件 peerDependencies 所指定依赖的包，然后在插件 import 或者 require 所依赖的包的时候，永远都是引用宿主环境统一安装的 NPM 包，最终解决插件与所依赖包不一致的问题。

### css @supports
一个demo，如果浏览器支持 CSS 网格功能，则应用 display: grid; 样式到 .site-content 的元素。不支持则降级

```css
@supports (display: grid) {
    .site-content {
        display: grid;
    }
}
@supports not (display: grid) {
    .site-content {
        float: left;
    }
}
```

## 6.3
### sass/less 版本问题

版本太高会报错：`TypeError: this.getOptions is not a function`

主要原因是高版本依赖webpack5,现在项目基本都没升级，所以降低loader版本即可
### commitizen: 标准化的commit message
`npm install -g commitizen`

基本都在用的git提交规范
### CSS 自定义变量
带有前缀--的属性名，比如--example--name，表示的是带有值的自定义属性，其可以通过 var 函数在全文档范围内复用的。
```css
 <style>
      :root {
        --global--color-primary: #1851ad;
        --global--color-danger: #880c21;
      }

      .btn {
        width: 100px;
        height: 50px;
        color: #999;
      }
      .btn-primary {
        background-color: var(--global--color-primary);
      }
      .btn-danger {
        background-color: var(--global--color-danger);
      }
    </style>
    <body>
    <div>
      <button class="btn btn-primary">主要按钮</button>
      <button class="btn btn-danger">错误按钮</button>
    </div>
  </body>
```

### 外界的干扰
各种其他的事情，会影响到自己的心态。

有时候就有会有放纵的心理，然后就会就想着算了
### 查找 mac 系统中所有的 node_modules

[npkill](https://github.com/voidcosmos/npkill)

```js
// 安装
sudo npm i -g npkill
// 查找
npx npkill
// 删除， 上下选中
space 空格键删除

```

## 6.2

### 一个 markdown 实时渲染的实现

之前疑惑的，掘金看了篇文章，恍然大悟。

基本就是：将输入框中的值通过开源库转换成 Html，再插入到页面。

```js
import React, { useState } from "react";
import "./theme/github-theme.css"; // 引入github的markdown主题样式
// markdown解析的开源库:Marked、Showdown、markdown-it，后者比较好用
import markdownIt from "markdown-it";

const md = new markdownIt();

export default function MarkdownEdit() {
  // 存储解析后的html字符串
  const [htmlString, setHtmlString] = useState("");
  // 解析markdown语法
  const parse = (text: string) => setHtmlString(md.render(text));

  return (
    <div className="markdownEditConainer">
      <textarea className="edit" onChange={(e) => parse(e.target.value)} />
      <div
        className="show"
        id="write" // 新增write的ID名
        dangerouslySetInnerHTML={{ __html: htmlString }}
      />
    </div>
  );
}
```

### 一个 webpack plugin

- Plugin 其实就是一个类。
- 类需要一个 apply 方法，执行具体的插件方法。
- 插件方法做了一件事情就是在 run 这个 Hook 上注册了一个同步的打印日志的方法。
- apply 方法的入参注入了一个 compiler 实例，compiler 实例是 Webpack 的支柱引擎，代表了 CLI 和 Node API 传递的所有配置项。
- Hook 回调方法注入了 compilation 实例，compilation 能够访问当前构建时的模块和相应的依赖。
- compiler 实例和 compilation 实例上分别定义了许多 Hooks，可以通过实例.hooks.具体 Hook 访问，Hook 上还暴露了 3 个方法供使用，分别是 tap、tapAsync 和 tapPromise。这三个方法用于定义如何执行 Hook，比如 tap 表示注册同步 Hook，tapAsync 代表 callback 方式注册异步 hook，而 tapPromise 代表 Promise 方式注册异步 Hook

```js
const pluginName = "ConsoleLogOnBuildWebpackPlugin";

class ConsoleLogOnBuildWebpackPlugin {
  // ​Compiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；
  apply(compiler) {
    // 代表开始读取records之前执行
    compiler.hooks.run.tap(pluginName, (compilation) => {
      //  Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。
      console.log("webpack 构建过程开始！");
    });
  }
}
```

## 6.1

### 剩余操作符

解构正常都知道，...other 第一次用到

```js
const a = { x: 1, y: 2, c: 3 };
const { x, ...other } = a;
x; // 1
other; // {y: 2, c: 3}
```

### 解构重命名

```js
const { y: renameY } = a;
renameY; // 2
```
